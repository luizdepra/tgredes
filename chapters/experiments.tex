\chapter{Experimentos}

	Nesse capítulo são descritos os experimentos realizados para comparação do uso de árvores multidimensionais com o MySQL na manipulação de dados multidimensionais. Na seção \ref{config_experiments} é descrita a máquina utilizada para os experimentos, tanto em nível de hardware quanto de software. Na seção \ref{database_generation} é apresentada a origem dos dados que forma utilizados nos experimentos. E finalmente, os experimentos foram divididos em duas partes: a seção \ref{kd_vs_mysql} apresenta os experimentos de comparação entre árvores \textit{K-D} e MySQL para monitoramento \textit{online}, seguida da seção \ref{kdb_vs_mysql} a qual apresenta os experimentos de comparação entre árvores \textit{K-D-B} e MySQL para monitoramento \textit{offline}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Configurações e Ambiente de Experimentação}
\label{config_experiments}
	
	Para a realização dos experimentos de comparação, foi utilizada uma máquina dedicada somente para esta atividade. A configuração de hardware dessa maquina é a seguinte: processador AMD Athlon XP 1800+, dois módulos de memória DDR 400 de 512MB e disco \textit{Saunsung} 40GB, 7200RPM.

	O sistema operacional utilizado é o Debian Lenny, com kernel linux 2.6.26. Todas as implementações relativas aos experimentos utilizam-se de ferramentas ou bibliotecas de código aberto. Para a implementação da árvore \textit{K-D} foi utilizada a biblioteca libkdtree++ \cite{libkdtree}, a qual possui todas as operações necessárias. A árvore \textit{K-D-B} foi implementada a partir da biblioteca TPIE \cite{tpie}, a qual provê vários mecanismos para trabalhar com a memória secundária com abstrações de alto nível.	As versões das bibliotecas utilizadas são as seguintes: libkdtree++ 0.7.0, tpie release '091905' e MySQL 5.0.51.

\section{Decisões de Implementação}
\label{impl_decisions}

	Os experimentos de comparação envolvem várias ferramentas distintas, e portanto, várias decisões de padronização foram tomadas. 
	
	A decisão inicial foi na forma de medição do tempo para as operações de inserção e busca. Como todas as ferramentas utilizam de \textit{C} ou \textit{C++}, foi escolhido um algoritmo para medição do tempo, o qual usa a função \textit{clock()} disponível na biblioteca time.h. Com essa função é possível alcançar a precisão de milisegundos, porém essa medida não é totalmente precisa - visto que foi amostrada em um sistema linux multitarefas.

	O tipo de arquivo de entrada a ser usado (texto ou binário) foi uma decisão tomada empiricamente. Sendo que o formato do arquivo de entrada também foi definido nesse mesmo tempo - cada linha representa um dado multidimensional, sendo que cada coluna representa uma dimensão desse dado. Através dos resultados obtidos nas figuras \ref{img_insert_4keys_kd_mysql} e \ref{img_search_4keys_kd_mysql}, verifica-se que o arquivo texto tem um desempenho levemente superior em relação ao arquivo binário tanto na inserção quanto na busca. Apesar disso, o espaço ocupado pelos arquivos binários 
	
	
	Para obtenção de resultados algumas escolhas foram tomadas ou definidas empiricamente. Por exemplo, o formato do arquivo de entrada segue um padrão: cada linha do arquivo representa um dado multidimensional, sendo que cada coluna representa uma dimensão desse dado. 
	Porém o tipo do arquivo de entrada foi definido através de experimentos.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Geração das Bases de Dados}
\label{database_generation}

	Os dados de entrada utilizados nos experimentos não são originados de monitoramento de redes reais. São dados gerados randomicamente através de um programa, o qual coloca em arquivo na forma de texto ou binário para que sejam utilizados posteriormente pelas ferramentas de comparação. Mesmo que a origem dos dados seja randômica, isso não afetaria o resultado em nenhum aspecto, visto que seriam dados de mesma natureza.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Árvore \textit{K-D} vs MySQL}
\label{kd_vs_mysql}


	Nesse experimento foram utilizados dois tipos de arquivo: binário e texto. A escolha para o resto dos experimentos foi pelo formato que gerava menos carga sobre o sistema, ou seja, o arquivo texto. Para simplificação do experimento, os testes foram feitos somente com registros de 4 chaves. A figura \ref{img_insert_4keys_kd_mysql} mostra a comparação para a inserção entre a árvore \textit{K-D} e o MySQL, analogamente a figura \ref{img_search_4keys_kd_mysql} mostra a comparação para a busca.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.6]{images/experiments/4keys_insertion_kdtree_mysql.jpg}
\caption{Árvore \textit{K-D} vs MySQL: inserção.}
\label{img_insert_4keys_kd_mysql}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.6]{images/experiments/4keys_search_kdtree_mysql.jpg}
\caption{Árvore \textit{K-D} vs MySQL: busca.} 
\label{img_search_4keys_kd_mysql}
\end{center}
\end{figure}

	A partir desse ponto, todos os experimentos foram feitos com 5 bases diferentes, sendo que o valor que aparece no gráfico é uma média das 5 medições. Além disso, as todas as bases possuem formato texto.

\subsection{Árvore \textit{K-D} vs MySQL: Inserção}

	A comparação da inserção entre a árvore \textit{K-D} e o MySQL, com chaves variando de 4, 8 e 16 estão na figura \ref{img_insert_Xkeys_kd_mysql}.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.6]{images/experiments/Xkeys_insertion_kdtree_mysql.jpg}
\caption{Árvore \textit{K-D} vs MySQL: inserção. Chaves variando de 4, 8 e 16.}
\label{img_insert_Xkeys_kd_mysql}
\end{center}
\end{figure}

\subsection{Árvore \textit{K-D} vs MySQL: Busca}
	
	O gráfico de busca da árvore \textit{K-D} foi omitido pois, em todos os testes, o tempo de retorno foi de 0ms até 2ms. Ou seja, não apareceria nenhuma linha no gráfico de comparação. A figura \ref{img_search_Xkeys_mysql} mostra o tempo para a busca no MySQL, com chaves variando entre 4, 8 e 16.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.6]{images/experiments/Xkeys_search_mysql.jpg}
\caption{MySQL: busca. Chaves variando de 4, 8 e 16.}
\label{img_search_Xkeys_mysql}
\end{center}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Árvore \textit{K-D-B} vs MySQL}
\label{kdb_vs_mysql}

	Como o uso da biblioteca da árvore \textit{K-D-B} é mais restrita, os experimentos utilizam somente chaves de tamanho 10.

\subsection{Árvore \textit{K-D-B} vs MySQL: Inserção}

	A figura \ref{img_insert_10keys_kdb_mysql} mostra a comparação entre a árvore \textit{K-D-B} e o MySQL. Um detalhe é que foi utilizado de indexação variando de 0 a 10 no MySQL.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.6]{images/experiments/10keys_insertion_kdbtree_mysql.jpg}
\caption{Árvore \textit{K-D-B} vs MySQL: Inserção}
\label{img_insert_10keys_kdb_mysql}
\end{center}
\end{figure}

\subsection{Árvore \textit{K-D-B} vs MySQL: Inserção Otimizada}

	Nesse experimento foi utilizada uma forma de inserção otimizada do MySQL, através da operação LOAD IN FILE \cite{mysqlLIF}. A figura \ref{img_insert_10keys_kdb_mysql_2} mostra o resultado dessa otimização no MySQL.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.6]{images/experiments/10keys_insertion_kdbtree_mysql2.png}
\caption{Árvore \textit{K-D-B} vs MySQL}
\label{img_insert_10keys_kdb_mysql_2}
\end{center}
\end{figure}

\subsection{Árvore \textit{K-D-B} vs MySQL: Busca}

	A comparação da busca entre a árvore \textit{K-D-B} e o MySQL com índices estão na figura \ref{img_search_10keys_kdb_mysql}.

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.6]{images/experiments/10keys_search_kdbtree_mysql.jpg}
\caption{Árvore \textit{K-D-B} vs MySQL: Busca}
\label{img_search_10keys_kdb_mysql}
\end{center}
\end{figure}
